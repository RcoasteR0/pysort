edges=[
    (0, 6, 343), (0, 21, 494), (0, 22, 303), (1, 5, 438), (1, 13, 221), 
    (1, 20, 465), (2, 14, 411), (2, 18, 66), (2, 19, 33), (2, 23, 479), 
    (3, 9, 150), (3, 17, 158), (3, 21, 457), (4, 14, 214), (4, 15, 305), 
    (4, 18, 509), (4, 22, 519), (4, 23, 157), (4, 24, 356), (5, 7, 286), 
    (5, 12, 481), (5, 13, 230), (5, 16, 439), (5, 17, 383), (5, 20, 199), 
    (6, 12, 516), (6, 15, 355), (6, 18, 492), (6, 19, 518), (6, 22, 256), 
    (6, 24, 306), (7, 11, 156), (7, 19, 486), (8, 12, 508), (8, 16, 373), 
    (8, 17, 203), (9, 10, 225), (9, 16, 413), (9, 17, 295), (10, 16, 213), 
    (10, 21, 358), (11, 13, 138), (11, 20, 193), (12, 13, 269), (12, 16, 135), 
    (13, 20, 327), (14, 15, 370), (14, 18, 345), (14, 19, 435), (14, 24, 348), 
    (15, 23, 373), (16, 21, 262), (17, 21, 437), (22, 24, 282), (23, 24, 374)
]
num_vertex = 25

print('Using Set Cover')

# Make U, F from Data
U = set(range(len(edges)))
F = [set() for _ in range(num_vertex)]
for i, (u, v, _) in enumerate(edges):
    F[u].add(i)
    F[v].add(i)
    # fill F: n 번째 정점을 선택하면 i 번째 간선이 커버된다

# 구하려는 Set Cover 해 정점들
vc = set()
while U:
    # print(U)
    max_i = max(range(num_vertex), key=lambda x: len(F[x] & U))
    # print(max_i, F[max_i])
    S = F[max_i] # U 에 살아있는 것과 가장 교집합이 많은 정점
    U -= S       # U 에서 max_i 번째 정점 선택했을 때 커버되는 간선들을 삭제한다
    F[max_i] = set() # remove max_i from F
    vc.add(max_i)

print(len(vc), vc)
# 13 {1, 3, 4, 5, 7, 9, 11, 15, 16, 19, 20, 21, 22}
